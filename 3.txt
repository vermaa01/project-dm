Q1. 10M

Creating a child process using the command exec(). Note down process ids of the parent and the child processes, check whether the control is given back to the parent after the child process terminates.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>

int main() 
{
 pid_t child_pid;
 child_pid = fork();
 if (child_pid < 0) 
 {
  perror("fork failed");
  exit(1);
 }
 if (child_pid == 0) 
 {
  printf("--- CHILD PROCESS ---\n");
  printf("Child PID: %d, Parent PID: %d\n", getpid(), getppid());
  printf("Child is now executing 'ls -l' using execlp()...\n\n");
  execlp("ls", "ls", "-l", NULL);
  perror("execlp failed");
  exit(1);
 }
 else 
 {
  printf("--- PARENT PROCESS ---\n");
  printf("Parent PID: %d, I created a child with PID: %d\n", getpid(), child_pid);
  printf("Parent is waiting for the child to terminate...\n");
  wait(NULL);
  printf("\n--- PARENT PROCESS HAS REGAINED CONTROL ---\n");
  printf("Child process has terminated. Control is back with the parent.\n");
 }
 return 0;
}


Q2. 20M

Write the simulation program using FCFS. The arrival time and first CPU bursts of different jobs should be input to the system. Assume the fixed I/O waiting time (2 units). The next CPU burst should be generated using random function. The output should give the Gantt chart,Turnaround Time and Waiting time for each process and average times. [20 marks]

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define MAX 100
int main() 
{
 int n;
 int pid[MAX], at[MAX], bt1[MAX], bt2[MAX];
 int st[MAX], et[MAX], tat[MAX], wt[MAX];
 int completed = 0;
 int current_time = 0;
 float total_tat = 0, total_wt = 0;
 srand(time(NULL));
 printf("Enter number of processes: ");
 scanf("%d", &n);
 for (int i = 0; i < n; i++)
 {
  pid[i] = i + 1;
  printf("Enter arrival time for Proecess P%d: ", pid[i]);
  scanf("%d", &at[i]);
  printf("Enter first CPU burst for Proecess P%d: ", pid[i]);
  scanf("%d", &bt1[i]);
  bt2[i] = (rand() % 5) + 1;
 }
 for(int i = 0; i < n - 1; i++)
 {
  for(int j = 0; j < n - i - 1; j++)
  {
   if(at[j] > at[j + 1])
   {
    int temp = at[j];
    at[j] = at[j + 1];
    at[j + 1] = temp;
    
    temp = pid[j];
    pid[j] = pid[j + 1];
    pid[j + 1] = temp;
    
    temp = bt1[j];
    bt1[j] = bt1[j + 1];
    bt1[j + 1] = temp;
    
    temp = bt2[j];
    bt2[j] = bt2[j + 1];
    bt2[j + 1] = temp;
   }
  }
 }
 printf("\nGantt Chart:\n");
 for (int i = 0; i < n; i++)
 {
  if(current_time < at[i])
  {
   current_time = at[i];
  }
  st[i] = current_time;
  
  current_time += bt1[i];
  
  current_time += 2;
  
  current_time += bt2[i];
  
  et[i] = current_time;
  
  tat[i] = et[i] - at[i];
  
  wt[i] = tat[i] - (bt1[i] + bt2[i]);
  
  total_tat += tat[i];
  total_wt += wt[i];
  printf(" P%d |", pid[i]);
 }
 printf("\n\nProcess\tAT\tBT1\tBT2\tCT\tTAT\tWT\n");
 for (int i = 0; i < n; i++)
 {
  printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n", pid[i], at[i], bt1[i], bt2[i], et[i], tat[i], wt[i]);
 }
 printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
 printf("Average Waiting Time  %.2f\n", total_wt / n);
 return 0;
}
